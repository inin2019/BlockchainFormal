\begin{zed}
Reporte::=~Okay~|~BloqueInvalido~|~Rechazo~\\
\\
\end{zed}
\begin{zed}
Success\defs[r!~:~Reporte~|~r!~=~Okay]\\
\end{zed}
\begin{zed}
[FINGERPRINT,~TIMESTAMP,~DATA]\\
\end{zed}
\begin{schema}{Bloque}
fingerprint:FINGERPRINT\\
prevblock:~FINGERPRINT\\
indice:~\nat\\
timestamp:~TIMESTAMP\\
data:~DATA\\
\end{schema}
\begin{axdef}
getFingerprint~:~Bloque~\fun~FINGERPRINT\\
createFingerprint:~BloqueEntrada\fun~FINGERPRINT\\
\end{axdef}
\begin{zed}
[IPADDRESS]\\
\end{zed}
\begin{zed}
Status~::=~Activo~|~Inactivo\\
\end{zed}
\begin{schema}{Nodo}
IP:~IPADDRESS\\
Estado:~Status\\
cadena:~\seq~Bloque\\
peers:~\power~IPADDRESS\\
\end{schema}
\begin{schema}{BloqueEntrada}
prevblock:~FINGERPRINT~\\
indice:~\nat\\
timestamp:~TIMESTAMP\\
data:~DATA\\
\end{schema}
\begin{schema}{CrearBloque}
entrada?:~BloqueEntrada\\
Nuevo!:~Bloque\\
\where
Nuevo!.fingerprint~=~createFingerprint~entrada?\\
Nuevo!.prevblock~=~entrada?.prevblock\\
Nuevo!.indice~=~entrada?.indice\\
Nuevo!.timestamp~=~entrada?.timestamp\\
Nuevo!.data~=~entrada?.data\\
\end{schema}
\begin{schema}{ValidarBloque}
\Xi Nodo\\
bloque?:~Bloque\\
m!:~Reporte\\
\where
bloque?.prevblock~=~(last~cadena).fingerprint\\
getFingerprint(bloque?)~=~bloque?.fingerprint\\
bloque?.indice~=~(last~cadena).indice~+~1\\
m!~=~Okay\\
\end{schema}
\begin{schema}{AgregarCadenaOk}
\Delta Nodo\\
nuevo?:~Bloque\\
m!:~Reporte\\
\where
nuevo?.prevblock~=~(last~cadena).fingerprint\\
nuevo?.fingerprint~=~getFingerprint(nuevo?)\\
cadena'~=~cadena~\cat~\langle nuevo?\rangle\\
m!~=Okay\\
\end{schema}
\begin{schema}{ReemplazarCadena}
\Delta Nodo\\
nuevaCadena?:~\seq~Bloque\\
\where
\#nuevaCadena?~>~\#cadena\\
cadena'~=~nuevaCadena?\\
\end{schema}
\begin{zed}
listarBloques~==~(~\lambda~Nodo;~b:~\seq~Bloque~@~cadena)\\
\end{zed}
\begin{axdef}
bloqueGenesis:~Bloque\\
\end{axdef}
\begin{axdef}
getIP:~\power~Nodo\fun IPADDRESS\\
\end{axdef}
\begin{schema}{InitBlockchain}
\Delta Nodo\\
\where
IP'~=~getIP(Nodo)\\
Estado'~=~Activo\\
cadena'~=~\langle~bloqueGenesis~\rangle\\
peers'~=~\emptyset\\
\end{schema}
\begin{schema}{TSalida}
ID:~FINGERPRINT\\
Timestamp:~TIMESTAMP\\
Direccion:~FINGERPRINT\\
Cantidad:~\nat_1\\
\end{schema}
\begin{schema}{TEntrada}
IDOut:~FINGERPRINT\\
Firma:~FINGERPRINT\\
\end{schema}
\begin{schema}{Transaccion}
ID:~FINGERPRINT\\
Salidas:~\power~TSalida\\
Entradas:~\power TEntrada\\
\end{schema}
\begin{axdef}
getPrivateKey:~FINGERPRINT\\
getPublicFromWallet:~FINGERPRINT\\
\end{axdef}
\begin{axdef}
getWalletBalance:~FINGERPRINT~\fun~\integer\\
\end{axdef}
\begin{schema}{MontoDisponible}
\Xi Transaccion\\
Wallet?:~FINGERPRINT\\
Monto?:~\integer\\
\where
Monto?~>~0\\
Monto?~\leq~getWalletBalance(Wallet?)\\
\end{schema}
\begin{axdef}
getTSalidas~:~\{user:~FINGERPRINT;monto:~\integer\}\fun\power TSalida\\
\end{axdef}
\begin{schema}{EnviarTransaccionOk}
\Delta Transaccion\\
Wallet?:~FINGERPRINT\\
Receiver:~FINGERPRINT\\
Monto?:~\integer\\
R!:~Reporte\\
\where
MontoDisponible\\
Monto?~>~0\\
Receiver~\neq~Wallet?\\
R!~=~Okay\\
\forall~t:~TSalida~|~t~\in~getTSalidas~(Wallet?,Monto?)~@~t.~Direccion~=~Receiver\\
\end{schema}
\begin{schema}{FondoInsuficiente}
\Xi Transaccion\\
Wallet?:~FINGERPRINT\\
Monto?:~\integer\\
R!~:~Reporte\\
\where
Monto?~>~0\\
Monto?~>~getWalletBalance(Wallet?)\\
R!~=~Rechazo\\
\end{schema}
\begin{zed}
RealizarTransferencia~\defs~(EnviarTransaccionOk~\land~Success)~\lor~FondoInsuficiente\\
\end{zed}
